/**
 * Merges two errors into one.
 *
 * Useful for errors generated by MongoDB calls. For some reason, those errors don't include the
 * full call stack, so it's a pain figuring out where an error came from. By passing in an error
 * that you defined,
 *
 * @param {Error} localError
 * @param {Error} apiError
 * @returns {Error}
 */
 export function mergeErrors(localError, apiError) {
  const merged = new Error();

  // if-block will still trigger if apiError is a more specific error type, like TypeError
  if (apiError instanceof Error) {
    merged.name = apiError.name;
    merged.message = `${localError.message}: ${apiError.message}`;
    merged.stack = `Local error info:\n${localError.stack}\n---\nAPI error info:\n${apiError.stack}`;
  } else {
    merged.name = localError.name;
    merged.message = `${localError.message}: API threw ${apiError}, which is not an error object`;
    merged.stack = localError.stack;
  }

  return Object.freeze(merged);
}

/**
 * Validates whether a request body is properly formatted for performing operations with the users
 * and sessions tables.
 *
 * @param {unknown} value
 * @returns {boolean}
 */
export function isValidUserBody(value) {
  return (
    value != null &&
    typeof value === "object" &&
    "username" in value &&
    "password" in value &&
    typeof value.username === "string" &&
    typeof value.password === "string" &&
    value.username.length > 0 &&
    value.password.length > 0
  );
}
